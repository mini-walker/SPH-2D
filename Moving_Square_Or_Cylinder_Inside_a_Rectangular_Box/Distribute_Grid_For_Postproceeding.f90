!**************************************************************************************************************
!  Subroutine : Distribute_Grid_For_Postproceeding 
!
!  PURPOSE    : Distribute Grid For Postproceeding
!
!  Programer  : Shanqin Jin (E-mail:sjin@mun.ca)
!
!  Location   : MUN
!
!  Time       : 2017.3.18
!
!  Copyright  : Memorial University
!
!  Version    : 1.0
!
!  Note       : MPI version: mpich-3.2
!               Fortran version: Inter Fortran (ifort) 18.0.0
!**************************************************************************************************************

subroutine Distribute_Grid_For_Postproceeding()

    USE Information_module
    USE Public_variable_module
    USE SPH_subroutine_module
    USE Wave_Gereration_Module
    USE Function_module
    USE MPI
    
    implicit none

    !==========================================================================================================
    ! Variables in subroutine
    integer::i,j,k,L,m                                                  ! Loop Variables
    integer::x_n,y_n,z_n                                                ! Backgroud Grid Location

    ! Read file varibales
    integer::skip_lines                                                 ! The skip lines number
    character(len=20)::temp_character                                   ! Temp characters for reading
    integer::File_index                                                 ! File index
    character(len=100)::File_name                                       ! File name ( The file name character lenghth should be 100 )

    !==========================================================================================================



    !==========================================================================================================
    ! For 2D case
    if (dim==2) then

        !======================================================================================================

        !------------------------------------------------------------------------------------------------------
        ! Allocate the memory for post-proceeding grid
        if ( Postproceeding_Grid_From_Input_Files/=1 ) then

            total_element_node_number = element_node_number_x*element_node_number_y
            total_element_number      = element_number_x*element_number_y

        else

            ! Postproceeding proceeding grid is generated by pointwise
            !--------------------------------------------------------------------------------------------------
            if ( Postproceeding_Grid_Initial_File_Type==2 ) then

                ! Open the input Pointwise data files
                File_index=General_File_Port
                File_name =Trim(adjustl(Postproceeding_File_Name))  
                call Initialziting_Reading_File( File_index,File_name,ioerror )

                if ( ioerror==0 ) then

                    ! Skip the initial five head titles
                    skip_lines=4
                    do i=1,skip_lines
                       read(File_index,*) temp_character
                    end do

                    ! Read node number
                    read(File_index,*) total_element_node_number

                    ! Read node coordiante
                    do k=1,total_element_node_number
                        
                        read(File_index,*)  temp_character

                    enddo

                    ! Skip the two lines
                    skip_lines=2
                    do i=1,skip_lines
                       read(File_index,*) temp_character
                    end do

                    ! Read element number and node number in one grid
                    read(File_index,*) total_element_number,NodeNumberInOneElement

                    do k=1,total_element_number
                        read(File_index,*) temp_character
                    enddo
                    
                endif

                ! Synchronize all processors calculation           
                call MPI_Barrier(MPI_COMM_WORLD,ierror_MPI)

                close(File_index)

            endif

        endif
        !------------------------------------------------------------------------------------------------------
        

        !------------------------------------------------------------------------------------------------------
        ! Allocate the memory for post-proceeding grid

        Allocate( element_node_position(total_element_node_number,dim) )                 ! Element node position
        Allocate( element_node_velocity(total_element_node_number,dim) )                 ! Element node velocity
        Allocate( element_node_vorticity(total_element_node_number,3) )                  ! Element node vorticity
        
        Allocate( element_node_press(total_element_node_number) )                        ! Element node pressure
        Allocate( element_node_Fai(total_element_node_number) )                          ! Element node level set value
        
        Allocate( temp_element_node_vorticity(total_element_node_number,3) )             ! Temp element node vorticity
        Allocate( temp_element_node_velocity(total_element_node_number,dim) )            ! Temp element node velocity
        Allocate( temp_element_node_press(total_element_node_number) )                   ! Temp element node pressure
        Allocate( temp_element_node_Fai(total_element_node_number) )                     ! Temp element node level set value


        Allocate( Reduce_Real_Array_For_Grid(total_element_node_number) )                ! Reduce Real Array For Grid 

        Allocate( element_node_Type(total_element_node_number) )                         ! Element node type
        Allocate( element_node_processor_index(total_element_node_number) )              ! Element node processor index
        Allocate( element_node_chain_number(total_element_node_number) )                 ! Element node chain number
        Allocate( element_node_index(total_element_node_number,8) )                      ! Element node index



        ! Analytical results for element nodes
        Allocate( Analytical_element_node_velocity(total_element_node_number,dim) )      ! Analytical particle velocity
        Allocate( Analytical_element_node_press(total_element_node_number) )             ! Analytical particle pressure
        Allocate( Analytical_element_node_velocity_magnitude(total_element_node_number)) ! Analytical element node magnitude
        Allocate( element_node_velocity_error(total_element_node_number,dim) )           ! Element node velocity relative error 
        Allocate( element_node_press_error(total_element_node_number) )                  ! Element node pressure relative error
        Allocate( element_node_velocity_magnitude_error(total_element_node_number) )     ! Element node velocity magnitude

        !------------------------------------------------------------------------------------------------------

        !======================================================================================================


        !======================================================================================================
        ! Generate the grid
        ! Distribute the grid for post-proceeding
        ! The grid origin is same with the Backgroud Grid

        if ( Postproceeding_Grid_from_input_files/=1 ) then

            ! Postproceeding proceeding grid is generated by program
            !--------------------------------------------------------------------------------------------------
            ! Generate the node for element
            k=0
            do i=1,element_node_number_y
                do j=1,element_node_number_x

                   k=k+1

                   element_node_position(k,1)=(j-1)*element_dx !+0.5*element_dx
                   element_node_position(k,2)=(i-1)*element_dx !+0.5*element_dx

                   element_node_Fai(k)=0.0d0

                enddo   
            enddo

            ! Connect grid for each element
            NodeNumberInOneElement=4
            
            do i=1,element_number_y
                do j=1,element_number_x            !1-m column
                    
                    k=j+(i-1)*element_number_x     !Element index
                    
                    !网格左下角第一个节点编号为网格编号加上当前行数-1(Anti-clockwise)
                    L=k+(i-1)

                    element_node_index(k,1)=L
                    element_node_index(k,2)=L+1
                    element_node_index(k,3)=L+element_node_number_x+1
                    element_node_index(k,4)=L+element_node_number_x

                end do
            
            end do
            !--------------------------------------------------------------------------------------------------

        else

            ! Postproceeding proceeding grid is generated by pointwise
            !--------------------------------------------------------------------------------------------------
            if ( Postproceeding_Grid_Initial_File_Type==2 ) then

                ! Open the input Gambit data files
                ! Open the input Pointwise data files
                File_index=General_File_Port
                File_name =Trim(adjustl(Postproceeding_File_Name))  
                call Initialziting_Reading_File( File_index,File_name,ioerror )

                if ( ioerror==0 ) then

                    ! Skip the initial five head titles
                    skip_lines=4
                    do i=1,skip_lines
                       read(File_index,*) temp_character
                    end do

                    ! Read node number
                    read(File_index,*) total_element_node_number

                    ! Read node coordiante
                    do k=1,total_element_node_number
                        
                        read(File_index,*)  (element_node_position(k,j),j=1,dim)
                        element_node_Fai(k)=0.0d0 

                    enddo

                    ! Skip the two lines
                    skip_lines=2
                    do i=1,skip_lines
                       read(File_index,*) temp_character
                    end do

                    ! Read element number and node number in one grid
                    read(File_index,*) total_element_number,NodeNumberInOneElement

                    do k=1,total_element_number
                        read(File_index,*) (element_node_index(k,j),j=1,NodeNumberInOneElement)
                    enddo
                    
                endif

                !call sleep( 5 )                         ! Sleep 5 seconds

                ! Synchronize all processors calculation           
                call MPI_Barrier(MPI_COMM_WORLD,ierror_MPI)

                close(File_index)
                
            endif
            !--------------------------------------------------------------------------------------------------

        endif
        !======================================================================================================


        !======================================================================================================
        ! Project all the grid node in the Backgroud grid
        do i=1,total_element_node_number

            x_n=floor((element_node_position(i,1)-chain_origin_x)/chain_dx+1)
            y_n=floor((element_node_position(i,2)-chain_origin_y)/chain_dy+1)

            ! Calculate the Backgroud Grid Index
            k=(y_n-1)*chain_x_number+x_n                       ! one row by row

            element_node_chain_number(i)=k                     ! Save the element node location in Backgroud grid

        enddo
        !======================================================================================================

    ! For 3D case
    elseif (dim==3) then

        ! Connect grid for each element
        NodeNumberInOneElement=8
        
    endif
    !==========================================================================================================


    !==========================================================================================================
    ! Output the initial post-proceeding grid 
    output:if (Current_Processor_ID==0) then

        !------------------------------------------------------------------------------------------------------
        ! Grid only
        
        ! Open the Smoke Line Output file
        File_index = General_File_Port
        File_name  = "./Initial_Data/Initial_Post_Proceeding_Grid.dat"
        call Initialziting_Writing_File( File_index,File_name,IOERROR )    ! Input variables : File_index,File_name,IOERROR
  
        if(IOERROR==0) then

            ! Input tecplot header
            write(File_index,*) "TITLE='Post_Proceeding_Grid'"             ! Tecplot title
            write(File_index,*) "VARIABLES= 'X' 'Y'"                       ! VARIABLES number
            write(File_index,*) "ZONE T= '0' ,N=",total_element_node_number,",E=",total_element_number,",DATAPACKING=POINT,ZONETYPE=FEQUADRILATERAL "   
            
            ! Domain name, number of nodes, number of cells, whether the data is on points or blocks (whether the data is points or blocks), cell type
            ! Cell type: FETRIANGLE,FEQUADRILATERAL,FETETRAHEDRON,FEBRICK
            ! For the hybrid grid, we should output the grid in different ZONES 
            
            do i=1,total_element_node_number
                write(File_index,100) (element_node_position(i,j),j=1,dim)
100             format(8F12.6) 
            end do
            
            do i=1,total_element_number
                write(File_index,110) (element_node_index(i,j),j=1,NodeNumberInOneElement)
110             format(8I8) 
            end do

        endif

        close(File_index)
        !------------------------------------------------------------------------------------------------------


        !------------------------------------------------------------------------------------------------------
        ! Node only
        File_index = General_File_Port
        File_name  = "./Initial_Data/Initial_Post_Proceeding_Node.dat"
        call Initialziting_Writing_File( File_index,File_name,IOERROR )             ! Input variables : File_index,File_name,IOERROR
  
        if(IOERROR==0) then
        
            ! Input tecplot header
            write(File_index,*) "TITLE='Post_Proceeding_Grid_Node'"                 ! Tecplot title
            write(File_index,*) "VARIABLES= 'X' 'Y'"                                ! VARIABLES number

            write(File_index,*) "ZONE I=",total_element_node_number," F=POINT"
            
            do i=1,total_element_node_number
                write(File_index,100) (element_node_position(i,j),j=1,dim)
            end do

        endif

        close(File_index)
        !------------------------------------------------------------------------------------------------------

    endif output
    !==========================================================================================================


!     !**********************************************************************************************************
!     !For checking
    
!     if (Current_Processor_ID==0) then
       
!        open(unit=5,file="Backgroud_Grid.dat",status="replace",position="rewind",action="write",iostat=ioerror)

!         !Output the vicinity gird name and number
!         do i=1,grid_max_number
           
!            !write(5,100) i,(grid_center_positon(i,j),j=1,dim),grid_near_mesh_number(i),(grid_near_mesh_name(i,j),j=1,grid_near_mesh_number(i))
!            write(5,100) i,grid_near_mesh_number(i),(grid_near_mesh_name(i,j),j=1,grid_near_mesh_number(i))
! 100        format(100I10) 
          
!            ! if(i==165) then
!            !     write(*,*) i,chain_near_mesh_number(i)
!            !     k=chain_near_mesh_number(i)
           
!            !     write(*,*) (chain_near_mesh_name(i,j),j=1,k)
!            ! end if

!         end do

!         close(5)

!     end if
!     !**********************************************************************************************************


end subroutine Distribute_Grid_For_Postproceeding